<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <script>
    
    function shortestCellPath(grid, sr, sc, tr, tc) {
      
      /**
      @param grid: integer[][]
      @param sr: integer
      @param sc: integer
      @param tr: integer
      @param tc: integer
      @return: integer
      */

	    let successors = (root, m) => {

        let connectedCells = [
          [root[0] - 1, root[1]],
          [root[0], root[1] - 1],
          [root[0] + 1, root[1]],
          [root[0], root[1] + 1]
        ]

        const validCells = connectedCells.filter((cell) => {
          return cell[0] >= 0 && cell[0] < m.length && cell[1] >= 0 && cell[1] < m[0].length
        })

        const successors = validCells.filter((cell) => {
          //return (m[cell[0]][cell[1]] !== m[root[0]][root[1]])
          return (m[cell[0]][cell[1]] !== 0)
        })

        return successors
      }

      const buildPath = (traversalTree, to) => {
        let path = [to]
        let parent = traversalTree[to]
        while (parent) {
          path.push(parent)
          parent = traversalTree[parent]
        }
        return path.reverse()
      }

      const bfs = (from, to) => {

        let traversalTree = []
        let visited = new Set
        let queue = []
        queue.push(from)

        while (queue.length) {
          let subtreeRoot = queue.shift()
          visited.add(subtreeRoot.toString())
          
          if (subtreeRoot.toString() === to.toString()) return buildPath(traversalTree, to)

          for (child of successors(subtreeRoot, grid)) {
            if (!visited.has(child.toString())){
              traversalTree[child] = subtreeRoot
              queue.push(child)
            }
          }
        }
      }

      let path = bfs([sr, sc], [tr, tc])

      return path ? path.length - 1 : -1
      
    }

    console.log(shortestCellPath([[1, 1, 1, 1], [0, 0, 0, 1], [1, 1, 1, 1]], 0, 0, 2, 0))
    console.log(shortestCellPath([[1, 1, 1, 1], [0, 0, 0, 1], [1, 0, 1, 1]], 0, 0, 2, 0))
    console.log(shortestCellPath([[1, 1, 1, 1], [1, 0, 0, 1], [1, 0, 1, 1]], 0, 0, 2, 0))
    
    </script>
  </body>
</html>

<!-- https://www.pramp.com/challenge/Y56aZmaj9Ptmd9wV9xvL -->
<!-- https://stackoverflow.com/questions/55239386/finding-shortest-path-in-two-dimensional-array-javascript -->
<!-- https://tutorialspoint.dev/data-structure/matrix-archives/shortest-distance-two-cells-matrix-grid -->
<!-- https://www.geeksforgeeks.org/shortest-distance-two-cells-matrix-grid/ -->